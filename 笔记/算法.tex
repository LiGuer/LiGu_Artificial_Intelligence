\documentclass{article} 
\usepackage{amsmath}
\usepackage[UTF8]{ctex}
\title{}\date{} \setlength{\parindent}{0pt} \linespread{1.25}
\usepackage{ntheorem}\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{geometry} \geometry{a4paper,left=2cm,right=2cm,top=1cm,bottom=1.5cm}

\begin{document}
\tableofcontents

\section{算法}
    \subsection{图论}

        \subsubsection{最短路径}
        *	[算法]: Dijkstra
                [步骤]:
                    [1] init dis[]
                    [2] 
        ----------------------------------------------------------------------------------
        *	[算法]: Floyd
                [输入]:	[1] 图的邻接矩阵Graph
                [输出]: [1] 距离矩阵Distance	[2] 后继节点矩阵Path
                [数据结构]:
                    * 邻接矩阵Graph, 即.图的权值矩阵
                    * 距离矩阵Distance: i到j最短路径长度
                    * 后继节点矩阵Path: 记录两点间的最短路径, 表示从Vi到Vj需要经过的点
                [原理]:
                    * Floyd的本质的动态规划, Dijkstra的本质是贪心
                    * 状态转移方程:
                        Distance[i,j] = min{ Distance[i,k] + Distance[k,j] , Distance[i,j] }
                [流程]:
                    [1] 初始化距离矩阵Distance = 权值矩阵Graph
                        初始化后继矩阵Path(i,j) = j
                    [2] 对于每一对顶点 i 和 j, 看是否存在点 k 使得u->k->v比已知路径更短
                            即. Distance[i,j] = min{ Distance[i,k] + Distance[k,j] , Distance[i,j] }
                        若是,则更新Distance, Path(i,j) = k
                [时间复杂度]:
                    Floyd	时间复杂度O(V³)【3个for()循环嵌套】,空间复杂度O(V²)【2个矩阵】
                    Dijkstra时间复杂度O(V²)
                [对比Dijkstra]:
                    Dijkstra一次只能算出给定两点间的最短路径。
                    Floyd   一次可以算出任意两点间的最短路径。

        \subsubsection{最小生成树}
        *	[算法]: Prim
                [输入]: 图的邻接链表[Graph], 节点数量[n]
                [输出]: 最小生成树,每一条有向边的 起点[TreeU],终点[TreeV],总边数[TreeCur]
                [原理]: 按点贪心, 每次加入已搜索点集u的最短边(u,v)，其中v不属于已搜索点集的点v
                [时间复杂度]: O(E·logV)
                [流程]:
                    [1] 初始化[已搜点集 VertexNew]
                    [2] 将第一个图的节点, 加入VertexNew
                    [3] 开始迭代, 直至所有节点均已搜索完成, 即VertexNew已满
                        [4] 在已搜点集, 寻找最短边(u,v), 其中u∈VertexNew, v ∉ VertexNew
                        [5] 将边(u,v)加入最小生成树， 将v加入VertexNew
        ----------------------------------------------------------------------------------
        *	[算法]: Kruskal
                [输入]: 图的边数据 起点[u] 终点[v] 权值[w] 边数[n]
                [输出]: 最小生成树,每一条有向边的 起点[TreeU],终点[TreeV],总边数[TreeCur]
                [时间复杂度] O(E·logV)
                [流程]:
                    [1] 初始化未搜索边集EdgeNew = E0图边集
                    [2] 开始迭代,直至未搜索边集为空集
                        [3] 在边集合,选择最短边(u,v)
                        [4] 若(u,v)不在同一颗树, u,v所在两棵树合并,(u,v)加入该树
                        [5] 点集中删(u,v)
                    [6] 最后剩下的那棵树,就是最小生成树
                Kruskal	是按边贪心，适合稀疏图。
                Prim	是按点贪心，适合稠密图。

        \subsubsection{网络最大流}
        *	[算法]: Dinic
                [原理]: 贪心 + "反悔"机制
                增广路: 就是源->汇的一条路径。
                    利用深搜DFS，找增广路。
                    利用广搜BFS，确定此时各顶点的层次。
                    利用添加反向边，协助"反悔"。
                    广搜BFS是Dinic对于EK的优化。
                    广搜BFS，用队列queue。
                    深搜BFS，用递归or栈stack。

        \subsubsection{商旅问题}
        *	[问题]: 遍历所有给定点的最短闭合路径.

\end{document}
