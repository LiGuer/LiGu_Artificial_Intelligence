
* 数据结构

    * 线性表
        * 数组

        * 链表
            * 基础性质
                list();											//构造函数
                iterator begin();								//首地址
                iterator end();									//末地址
                bool empty();									//判断为空
                int size();										//元素数量
            * 基础操作
                node* insert(iterator position, T& x);			//插入
                void erase(iterator position);					//删除
                void push_front(const T& x);					//首末插入删除
                void push_back(const T& x);
                void pop_front();
                void pop_back();
                void clear();									//全清
                iterator search(T& x);							//查找

        * 队列
            * 先进后出

        * 栈
            * 先进先出

    * 树
        * 二叉树

        * 红黑树
            \Property
                * Every node is either red or black.
                * The root is black.
                * Every leaf (NIL) is black.
                * If a node is red, then both its children are black.
                * For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.

            * API:
                min、max、search						//搜索
                left_rotate、right_rotate				//旋转
                insert									//插入
                erase									//删除

    * 堆

    * 图

    * Hash表


* 算法
    * 排序
        * 快速排序
        *	[输入]: *first: 最初元素地址	*last: 最末元素地址 + 1
        *	[时间复杂度]: 上限n²，大概率平均值n log(n)
        *	[流程]: 
        *		* 最后元素作为参考元素[Ref]，[border]分割比参考元素大或小的界限，指向大的最初段
                * [ai] 从第一元素开始，直至 Ref 前一元素位置
                *	1).若 ai >=Ref, 不处理
                    2).若 ai < Ref, 
                        ai 与 border元素交换位置, border++
                * 遍历结束后, 交换Ref 与 border
                * Ref 左右比他大/小的两方元素，分别从头开始. 
            
        * 堆排序

    * 图论

        * 最短路径
            * Dijkstra

            * Floyd
                [输入]:	* 图的邻接矩阵Graph
                [输出]: * 距离矩阵Distance	* 后继节点矩阵Path
                [数据结构]:
                    * 邻接矩阵Graph, 即.图的权值矩阵
                    * 距离矩阵Distance: i到j最短路径长度
                    * 后继节点矩阵Path: 记录两点间的最短路径, 表示从Vi到Vj需要经过的点
                [原理]:
                    * Floyd的本质的动态规划, Dijkstra的本质是贪心
                    * 状态转移方程:
                        Distance[i,j] = min{ Distance[i,k] + Distance[k,j] , Distance[i,j] }
                [流程]:
                    * 初始化距离矩阵Distance = 权值矩阵Graph
                        初始化后继矩阵Path(i,j) = j
                    * 对于每一对顶点 i 和 j, 看是否存在点 k 使得u->k->v比已知路径更短
                            即. Distance[i,j] = min{ Distance[i,k] + Distance[k,j] , Distance[i,j] }
                        若是,则更新Distance, Path(i,j) = k
                [时间复杂度]:
                    Floyd	时间复杂度O(V³)【3个for()循环嵌套】,空间复杂度O(V²)【2个矩阵】
                    Dijkstra时间复杂度O(V²)

            * 对比Dijkstra \& Floyd
                Dijkstra一次只能算出给定两点间的最短路径. 
                Floyd   一次可以算出任意两点间的最短路径. 

        * 最小生成树
            * Prim
                [输入]: 图的邻接链表[Graph], 节点数量[n]
                [输出]: 最小生成树,每一条有向边的 起点[TreeU],终点[TreeV],总边数[TreeCur]
                [原理]: 按点贪心, 每次加入已搜索点集u的最短边(u,v)，其中v不属于已搜索点集的点v
                [时间复杂度]: O(E·logV)
                [流程]:
                    * 初始化[已搜点集 VertexNew]
                    * 将第一个图的节点, 加入VertexNew
                    * 开始迭代, 直至所有节点均已搜索完成, 即VertexNew已满
                        * 在已搜点集, 寻找最短边(u,v), 其中u∈VertexNew, v ∉ VertexNew
                        * 将边(u,v)加入最小生成树， 将v加入VertexNew

            * Kruskal
                [输入]: 图的边数据 起点[u] 终点[v] 权值[w] 边数[n]
                [输出]: 最小生成树,每一条有向边的 起点[TreeU],终点[TreeV],总边数[TreeCur]
                [时间复杂度] O(E·logV)
                [流程]:
                    * 初始化未搜索边集EdgeNew = E0图边集
                    * 开始迭代,直至未搜索边集为空集
                        * 在边集合,选择最短边(u,v)
                        * 若(u,v)不在同一颗树, u,v所在两棵树合并,(u,v)加入该树
                        * 点集中删(u,v)
                    * 最后剩下的那棵树,就是最小生成树

            * 对比Prim \& Kruskal
                Kruskal	是按边贪心，适合稀疏图. 
                Prim	是按点贪心，适合稠密图. 

        * 网络最大流
            * Dinic
                [原理]: 贪心 + "反悔"机制
                增广路: 就是源->汇的一条路径. 
                    利用深搜DFS，找增广路. 
                    利用广搜BFS，确定此时各顶点的层次. 
                    利用添加反向边，协助"反悔". 
                    广搜BFS是Dinic对于EK的优化. 
                    广搜BFS，用队列queue. 
                    深搜BFS，用递归or栈stack. 

        * 商旅问题
            \def{商旅问题} 遍历所有给定点的最短闭合路径.

    * 动态规划