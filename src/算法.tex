\section 数据结构

    \section 线性表
        \section 数组

        \section 链表
        * 核心数据
            node* head;										//链表头地址
        * 基础性质
            list();											//构造函数
            iterator begin();								//首地址
            iterator end();									//末地址
            bool empty();									//判断为空
            int size();										//元素数量
        * 基础操作
            node* insert(iterator position, T& x);			//插入
            void erase(iterator position);					//删除
            void push_front(const T& x);					//首末插入删除
            void push_back(const T& x);
            void pop_front();
            void pop_back();
            void clear();									//全清
            iterator search(T& x);							//查找

        \section 队列
            * 先进后出

        \section 栈
            * 先进先出

    \section 树
        \section 二叉树

        \section 红黑树
        * red-black properties:
            * Every node is either red or black.
            * The root is black.
            * Every leaf (NIL) is black.
            * If a node is red, then both its children are black.
            * For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.
        * API:
            min、max、search						//搜索
            left_rotate、right_rotate				//旋转
            insert									//插入
            erase									//删除

    \section 堆

    \section 图

    \section Hash 表


\section 算法
    \section 排序
        \section 快速排序
        *	[输入]: [1]first: 最初元素地址	[2]last: 最末元素地址 + 1
        *	[时间复杂度]: 上限n²，大概率平均值n log(n)
        *	[流程]: 
        *		[1] 最后元素作为参考元素[Ref]，[border]分割比参考元素大或小的界限，指向大的最初段
                [2] [ai] 从第一元素开始，直至 Ref 前一元素位置
                [3]	1).若 ai >=Ref, 不处理
                    2).若 ai < Ref, 
                        ai 与 border元素交换位置, border++
                [4] 遍历结束后, 交换Ref 与 border
                [5] Ref 左右比他大/小的两方元素，分别从头开始。

            \code{
                void sort(T* first, T* last, bool*(cmp)(T a, T b))
                {
                    if (last - 1 <= first)return;
                    T* ref = last - 1;			//最后元素作为参考元素
                    T* border = first;			//分割比参考元素大或小的界限，指向大的最初段
                    for (T* i = first; i != ref; i++) {
                        if (*i < *ref) {				//[3]
                            T temp = *border;
                            *border = *i; *i = temp;
                            border++;
                        }
                    }
                    T temp = *border; *border = *ref; *ref = temp;
                    sort(first, border, cmp);
                    sort(border + 1, last, cmp);
                }
            }
            
        \section 堆排序

    \section 图论

        \section 最短路径
        * [算法]: Dijkstra
                [步骤]:
                    [1] init dis[]
                    [2]  
        * [算法]: Floyd
                [输入]:	[1] 图的邻接矩阵Graph
                [输出]: [1] 距离矩阵Distance	[2] 后继节点矩阵Path
                [数据结构]:
                    * 邻接矩阵Graph, 即.图的权值矩阵
                    * 距离矩阵Distance: i到j最短路径长度
                    * 后继节点矩阵Path: 记录两点间的最短路径, 表示从Vi到Vj需要经过的点
                [原理]:
                    * Floyd的本质的动态规划, Dijkstra的本质是贪心
                    * 状态转移方程:
                        Distance[i,j] = min{ Distance[i,k] + Distance[k,j] , Distance[i,j] }
                [流程]:
                    [1] 初始化距离矩阵Distance = 权值矩阵Graph
                        初始化后继矩阵Path(i,j) = j
                    [2] 对于每一对顶点 i 和 j, 看是否存在点 k 使得u->k->v比已知路径更短
                            即. Distance[i,j] = min{ Distance[i,k] + Distance[k,j] , Distance[i,j] }
                        若是,则更新Distance, Path(i,j) = k
                [时间复杂度]:
                    Floyd	时间复杂度O(V³)【3个for()循环嵌套】,空间复杂度O(V²)【2个矩阵】
                    Dijkstra时间复杂度O(V²)
                [对比Dijkstra]:
                    Dijkstra一次只能算出给定两点间的最短路径。
                    Floyd   一次可以算出任意两点间的最短路径。

        \section 最小生成树
        * [算法]: Prim
                [输入]: 图的邻接链表[Graph], 节点数量[n]
                [输出]: 最小生成树,每一条有向边的 起点[TreeU],终点[TreeV],总边数[TreeCur]
                [原理]: 按点贪心, 每次加入已搜索点集u的最短边(u,v)，其中v不属于已搜索点集的点v
                [时间复杂度]: O(E·logV)
                [流程]:
                    [1] 初始化[已搜点集 VertexNew]
                    [2] 将第一个图的节点, 加入VertexNew
                    [3] 开始迭代, 直至所有节点均已搜索完成, 即VertexNew已满
                        [4] 在已搜点集, 寻找最短边(u,v), 其中u∈VertexNew, v ∉ VertexNew
                        [5] 将边(u,v)加入最小生成树， 将v加入VertexNew
        * [算法]: Kruskal
                [输入]: 图的边数据 起点[u] 终点[v] 权值[w] 边数[n]
                [输出]: 最小生成树,每一条有向边的 起点[TreeU],终点[TreeV],总边数[TreeCur]
                [时间复杂度] O(E·logV)
                [流程]:
                    [1] 初始化未搜索边集EdgeNew = E0图边集
                    [2] 开始迭代,直至未搜索边集为空集
                        [3] 在边集合,选择最短边(u,v)
                        [4] 若(u,v)不在同一颗树, u,v所在两棵树合并,(u,v)加入该树
                        [5] 点集中删(u,v)
                    [6] 最后剩下的那棵树,就是最小生成树
                Kruskal	是按边贪心，适合稀疏图。
                Prim	是按点贪心，适合稠密图。

        \section 网络最大流
        * [算法]: Dinic
                [原理]: 贪心 + "反悔"机制
                增广路: 就是源->汇的一条路径。
                    利用深搜DFS，找增广路。
                    利用广搜BFS，确定此时各顶点的层次。
                    利用添加反向边，协助"反悔"。
                    广搜BFS是Dinic对于EK的优化。
                    广搜BFS，用队列queue。
                    深搜BFS，用递归or栈stack。

        \section 商旅问题
        * [问题]: 遍历所有给定点的最短闭合路径.

    \section 动态规划